<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!--我们可以给模板当中的属性增加一个收集器 dep-->
    <!--页面渲染的时候将渲染逻辑封装到watcher(观察者)中 渲染逻辑vm._update(vm._render())-->
    <!--让dep记住watcher ，属性变化后就可以找到对应的dep中存放的watcher进行重新渲染-->
    <!--观察者模式-->
    <div id="app" style="background: yellow; ">
        <div style="color: #ebebeb; ">
            {{name}} hello {{name}} red
        </div>
       
        <span>
            {{age}}
        </span>
    </div>
    <script src="./vue.js"></script>
    <script>
        const vm = new Vue({
            data() { //c数据进行代理
                return {
                    name: "zf",
                    age: 20,
                    address: {
                        num: 40,
                        content: "回龙观"
                    },
                    hobby: ['eat', 'drink', {
                        a: 1
                    }]
                }
            },
            el: "#app" //我们要将数据解析到el元素上
        });
        // nextTick 不是创建了一个异步任务 ，而是将这个任务维护到了 队列中而已
        vm.$nextTick(() => {
            vm.name = "hmj"
        })
        // setTimeout(() => {
        //     vm.age = 23

        //     // vm._update(vm._render()) // 重新根据数据渲染出一个新的虚拟DOM
        // },1000)
        /**
         *  1.模板引擎 性能差 需要正则匹配替换 1.0的时候没有引入虚拟DOM
         *  2.采用虚拟DOM 数据变化后比较虚拟DOM的差异 最后更新需要更新的地方
         *  3.核心就是我们需要将模板变成js语法 ，通过js生成虚拟DOM
         *   想变成语法树再重新组装代码成为新的语法  将template语法转化成render方法
         */


         /**
          * 1) 将数据先处理成响应式 通过initState方法 针对于对象来说主要是增加defineProperty方法 针对数组而言就是重写方法
          * 2) 模板编译：将模板编译成ast语法树，将ast语法树生成render方法
          * 3) 调用render函数 会进行取值操作 产生对应的虚拟DOM render(){_c('div',null,_v(name))} 会触发get方法
          * 4) 将虚拟DOM渲染成真实DOM
          * 
          */
    </script>
</body>

</html>